{"version":3,"file":"install.js","sources":["uni_modules/tuniaoui-vue3/utils/vue/install.ts"],"sourcesContent":["import { isEmptyVariableInDefault } from '../is-empty'\nimport type { App, Directive } from 'vue'\nimport type { SFCInstallWithContext, SFCWithInstall } from './typescript'\n\n// 注册组件\nexport const withInstall = <T, E extends Record<string, any>>(\n  main: T,\n  extra?: E\n) => {\n  // 将组件注册到应用程序中\n  ;(main as SFCWithInstall<T>).install = (app: App) => {\n    for (const comp of [\n      main,\n      ...Object.values(isEmptyVariableInDefault<E>(extra, {})),\n    ]) {\n      app.component(comp.name, comp)\n    }\n  }\n\n  // 为组件添加额外的属性\n  if (extra) {\n    for (const [key, comp] of Object.entries(extra)) {\n      ;(main as any)[key] = comp\n    }\n  }\n\n  return main as SFCWithInstall<T> & E\n}\n\n// 将 fn 包装成一个带有 install 方法的 Vue 3 插件，并返回包装后的插件函数\nexport const withInstallFunction = <T>(fn: T, name: string) => {\n  ;(fn as SFCWithInstall<T>).install = (app: App) => {\n    ;(fn as SFCInstallWithContext<T>)._content = app._context\n    app.config.globalProperties[name] = fn\n  }\n\n  return fn as SFCInstallWithContext<T>\n}\n\n// 注册指令\nexport const withInstallDirective = <T extends Directive>(\n  directive: T,\n  name: string\n) => {\n  ;(directive as SFCWithInstall<T>).install = (app: App) => {\n    app.directive(name, directive)\n  }\n}\n\n// 返回一个新的组件对象，这个组件对象具有一个空的 install 方法\nexport const withNoopInstall = <T>(component: T) => {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ;(component as SFCWithInstall<T>).install = () => {}\n\n  return component as SFCWithInstall<T>\n}\n"],"names":[],"mappings":";AAkDa,MAAA,kBAAkB,CAAI,cAAiB;AAEhD,YAAgC,UAAU,MAAM;AAAA,EAAA;AAE3C,SAAA;AACT;;"}